---
title: "Comparative analysis of the gut microbiota composition of healthy people and people with diarrhoea-predominant irritable bowel syndrome"
author: "O.N. Potanina, A. Sozontov, D. Syrkova, A. Soroka, E. Shelly, E. Chukhrova"
output:
  html_document:
    toc: yes
    toc_float:
      collapsed: false
      smooth_scroll: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, error = FALSE)
library(readxl)
library(openxlsx)
library (tidyverse)
library(vegan)
library(broom) 
library (flextable)
```

# Data preprocessing

## Uploading, merging, and editing source datasets

```{r, message=FALSE}

info_healthy <- read_xlsx ("data/raw/final_health_statistic.xlsx") #metadata of healthy subjects 
info_ibs <- read_xlsx ("data/raw/final_ibs_141_statistic.xlsx") ##metadata of IBS subjects

```

```{r, echo=FALSE, eval=FALSE}

#Variables comparison in `info_healthy` and `info_ibs`
cat (
c ("Unique variables в info_ibs:", info_ibs %>% 
  select (- c (intersect (names(info_healthy), names(info_ibs)))) %>% colnames()),
c ("Unique variables в info_healthy:", info_healthy %>% 
  select (- c (intersect (names(info_ibs), names(info_healthy)))) %>% colnames()), 
sep = "\n") 

```

#### combined_info dataset

```{r combined_info, message=FALSE, warning=FALSE, error=FALSE}

#Combining `info_healthy` and `info_ibs` into a single dataset `combined_info` with subsequent content editing
combined_info <- info_healthy %>% 
  bind_rows(info_ibs) %>%
  mutate (
    BMI_min = ifelse (is.na (BMI_min), round (Weight_min /(Height_max/100 * Height_max/100), 2), BMI_min),
    BMI_max = ifelse (is.na (BMI_max), round (Weight_max /(Height_min/100 * Height_min/100), 2), BMI_max)
    ) %>% 
  unite("BMI_range", BMI_min, BMI_max, sep = "-", na.rm = TRUE) %>%
  unite ("Age_range", Age_min, Age_max, sep = "-", na.rm = TRUE) %>%
  mutate(
    Age_range = case_when(
      Age_range == "18-40" | Age_range == "23-28" | Age_range == "16-42" | Age_range == "21-43" ~ "16-43",
      Age <= 43 ~ "16-43",
      Age > 43 ~ "> 43",
      TRUE ~ NA_character_), #group 28-54 has been deleted
    research_ID = sub ("research_", "", research_ID),
    research_ID = case_when(
      research_ID == 0 ~ 1,
      research_ID == 1 ~ 2,
      research_ID == 2 ~ 3,
      research_ID == 3 ~ 4,
      research_ID == 4 ~ 5, 
      research_ID == 6 ~ 6, 
      research_ID == 7 ~ 7), 
    patient_ID = row_number(),
    Sex = ifelse (Sex == "mixed", NA, Sex),
    Smoking = sub ("never", "Never",  Smoking),
    Smoking = case_when(
      Smoking == "No" ~ "No",
      Smoking == "Never" ~ "No",
      Smoking == "Rarely (a few times/month)" ~ "Yes", #5 people
      Smoking == "Occasionally (1-2 times/week)" ~ "Yes",  #3 people
      Smoking == "Regularly (3-5 times/week)" ~ "Yes",  #1 people
      Smoking == "Daily" ~ "Yes"), #7 чел.
    Alcohol = sub ("rarely", "Rarely", Alcohol),
    Alcohol = ifelse(Alcohol == "Regularly (3-5 times/week)"|
                       Alcohol == "Daily", #3 чел.
                     "Regularly (3-7 times/week)", Alcohol),
    Antibiotics_usage = case_when(
      Antibiotics_usage == "Month" | Antibiotics_usage == ~ "3 months" |
        Antibiotics_usage == "6 months" ~ "1-6 months",
        #2 IBS people - Month, 0 healthy people - 3 months, 0 healthy people - 6 months
      Antibiotics_usage == "Year" | Antibiotics_usage == "Not use"  ~ 
        "12 months/Not use"), # 0 healthy people - 6-12 months, zero IBS people - Not use
    Hygiene = case_when(
      Hygiene == "Occasionally (1-2 times/week) cosmetics" ~ "Occasionally cosmetics (1-2 times/week)",
      Hygiene == "Rarely (a few times/month) cosmetics" ~ "Rarely cosmetics (a few times/month)",
      TRUE ~ Hygiene),
    Hygiene = case_when(
      Hygiene == "Daily cosmetics"|Hygiene == "Regularly cosmetics (3-5 times/week)" ~ "Regularly (3-7 times/week)", #0 чел. больных  для 3-5 times/week
      Hygiene == "Occasionally cosmetics (1-2 times/week)" | Hygiene == "Rarely cosmetics (a few times/month)" ~ "Occasionally (a few-8 times/month)",
      #только 2 чел. больных для 1-2 times/week
      Hygiene == "Never cosmetics" ~ "Never"),
    Physical_activity = sub ("regularly", "Regularly",  Smoking),
    BMI = ifelse (is.na(Weight_kg), BMI, Weight_kg/ (Height_cm/100 * Height_cm/100)),
    BMI_range = ifelse(BMI_range == "", NA, BMI_range),
    BMI_category = case_when(
      BMI_range == "18-25" ~ "normal/overweight",
      BMI_range == "19.21-29.29" ~ "normal/overweight",
      BMI_range == "20.6-29.6" ~ "normal/overweight",
      BMI_range == "21.74-28.38" ~ "normal/overweight",
      BMI_range == "18.5-30.8" ~ "normal/overweight", #a little over 30
      BMI < 18.5 ~ "underweight",
      BMI >= 18.5 & BMI < 30 ~ "normal/overweight",
      BMI >= 30 ~ "obese")
    ) %>% 
  rename ("Cosmetics" = Hygiene ) %>% 
  
  mutate_if (is.character, as.factor) %>% 
  
  select(-c(
    Instrument, # unique (combined_info$Instrument) = "Illumina MiSeq" 
    Isolation_source, # unique (combined_info$Isolation_source) = "faeces" 
    Assay_type, # unique (combined_info$Assay_type) = "AMPLICON"
    Target_gene, # unique (combined_info$Target_gene) = "16S"
    Main_Disease, # unique (combined_info$Main_Disease) = NA (for healthy), 141 (for IBS)
    Drugs, # unique (combined_info$Drugs) = NA
    Social_status, # unique (combined_info$Social_status) =  NA, urban 
    Weight_kg, Height_cm, Weight_min, Weight_max, Height_min, Height_max, BMI_range, #have been used to create the variable "BMI_category" and to reduce the amount of NA in "BMI"
    BMI, # NA for all healthy people
    Birth_Year, # no additional information
    Pets_type # unique (combined_info$Pets_type = cat, NA
  ))

rm (info_healthy, info_ibs)

#install.packages("summarytools")
library(summarytools)

saved_x11_option <- st_options("use.x11")
st_options(use.x11 = FALSE)

combined_info %>% 
  select(- patient_ID) %>% 
  dfSummary() %>% 
  print (method = "render")

```

```{r, message=FALSE}

combined_info %>% 
  select (research_ID, Country, Seq_date, Seq_region, Health_state) %>% 
  mutate(Country = if_else (research_ID == 4, "Australia, Austria, Germany, Greece, Hungary, Ireland, Israel, Italy, Norway, UK, USA", Country),
         Seq_date = ifelse (research_ID == 4, "2018-2023", Seq_date),
         Health_state = if_else (research_ID == 4, "Disease/Health", Health_state)) %>% 
  group_by(research_ID, Country, Seq_date, Seq_region, Health_state) %>% 
  summarise(n = n()) %>% 
  flextable() %>% theme_box() %>% 
  merge_v("Health_state") %>% 
  align(align = "center", part = "all") %>% 
  set_caption("General characteristics of the included studies")

```

#### tbl_summary of combined_info

```{r, message=FALSE}

library(gtsummary)

combined_info %>% 
  select(! c(patient_ID,
              Diet_duration, Additive_usage, Diet_type #for all healthy subjects = NA
              )) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Health_state) %>%
  add_p()

```

###combined_bacteria and data_wide (not batched) datasets

```{r combined_bacteria, message = FALSE}

bacteria_healthy <- read_csv("data/raw/final_bacteria_health.csv") #abundance table for healthy
bacteria_ibs <- read_csv("data/raw/final_bacteria_ibs_141.csv") #abundance table for healthy

combined_bacteria <- bacteria_healthy %>% 
  bind_rows (bacteria_ibs) %>% 
  mutate(patient_ID = row_number())

rm (bacteria_healthy, bacteria_ibs)

# Combining `combined_info` and `combined_bacteria` into `data_wide`
data_wide <- combined_info %>% left_join (combined_bacteria)

```

 

## Estimation of the NA-proportion and zero values

```{r}

data_wide %>% 
  select (where (function(x) sum (is.na(x))/ nrow(data_wide) * 100 > 0)) %>% 
  sapply (function(x) sum (is.na(x))/ nrow(data_wide) * 100) %>% round(1) %>% 
  as.data.frame() %>% 
  rename(NA_percentage = ".") %>% 
  mutate (
    "Number of people with known data" = round (nrow(data_wide) - NA_percentage/100 * nrow(data_wide)),
    NA_percentage = paste (NA_percentage, "%", sep = " ")
    ) %>% 
  arrange(desc (NA_percentage)) %>% 
  rownames_to_column() %>% 
  as_tibble() %>% flextable()

```

- Estimation of the NA-proportion and zero values *in variables* of `data_wide`

```{r calculate percentage for each variable}

# Устанавливаем порог процента 
threshold_percent <- 95 
 
# Функция для вычисления процента записей, не равных NA и не равных 0, для каждой колонки 
calculate_percentage <- function(col) { 
  sum(!is.na(col) & col != 0) / length(col) * 100 
} 
 
# Применяем функцию к каждой колонке в датасете 
percentage_non_zero_non_na <- sapply(data_wide[, -1], calculate_percentage) 
 
# Создаем датафрейм с результатами 
result_df_sort <- data.frame( 
  column = names(percentage_non_zero_non_na), 
  percentage = round(100 - percentage_non_zero_non_na, 2) # percentage означает пропущенные или 0 значения
) %>% 
  arrange(desc(percentage))
 
# Отфильтровываем колонки, у которых процент записей менее threshold_percent% 
filtered_columns <- result_df_sort[result_df_sort$percentage < threshold_percent, ]

# Сохраним датасет в excel для дальнейшего анализа
write.xlsx(filtered_columns, 
           file = "data/originals/percentage_by_vars.xlsx")

# Перезапись data_wide с выбором колонок с процентом NA/0 менее threshold_percent 
data_wide <- data_wide %>% 
  select (row.names(filtered_columns), research_ID)

rm (calculate_percentage, result_df_sort)

```

- Estimation of the NA-proportion and zero values *in cases* of `data_wide`

```{r}

# Устанавливаем порог процента 
threshold_percent <- 95
 
# Рассчитываем процент значений, не являющихся NA и не равных 0, для каждого пациента 
percentage_non_zero_non_na <- rowMeans(!is.na(data_wide) & data_wide != 0, na.rm = TRUE) * 100 
 
# Создаем датафрейм с результатами 
result_df_sort <- data.frame( 
  patient_id = data_wide$patient_ID, 
  percentage = round(100 - percentage_non_zero_non_na, 2) # percentage означает пропущенные или 0 значения
) %>% arrange(desc(percentage))

# Отфильтровываем пациентов, у которых процент значений менее threshold_percent% 
filtered_patients <- result_df_sort[result_df_sort$percentage < threshold_percent, ] 

# Сохраним датасет в excel для дальнейшего анализа 
write.xlsx(filtered_patients,
           file = "data/originals/percentage_by_patient.xlsx") 

# Перезапись data_wide с удалением строк с процентом NA/0 более threshold_percent 
data_wide <- data_wide %>% 
  slice (filtered_patients$patient_id) #при threshold_percent = 95%, изменения data_wide не происходит, так как нет пациентов с процентом NA/0 более 95%

rm (percentage_non_zero_non_na, result_df_sort)

```


```{r}

# Deleting columns and rows with a NA/0-percentage more than threshold_percent from `data_wide`
data_wide <- data_wide %>% 
  select (patient_ID, any_of (colnames(combined_info)), everything()) %>% 
  arrange(patient_ID)

```

 

## Search for "single study taxa"

- G-taxa

```{r}

G_only_one <- data_wide %>% 
  select (research_ID, ends_with("_G")) %>%
  add_column(n = 1) %>% #for further counting the subjects number in each study
  group_by(research_ID) %>% 
  summarise_each (sum) %>% 
  select (research_ID, n, where (function(x) sum (x!=0) == 1)) %>%  #selecting "single study taxa"
  mutate (across(-c(1:2), function(x) x/n)) %>% 
  mutate (across(-c(1:2), function(x) round (x,3))) 

G_only_one %>% as_tibble() %>% flextable() %>% set_caption("Mean percentage of single study G-taxa")

#Determining the percentage of people in whom these taxa have not been detected
G_taxon <- 'Ellin517_G'
res_ID <- 7

#data_wide %>% 
  #select (research_ID, G_taxon) %>%
  #filter (research_ID == res_ID) %>% 
  #summarise(across (-1,
              #function (x) sum (x==0)/nrow (.) * 100)) %>% 
  #rename ("Taxon_zero_percentage, %" = G_taxon) 

# CM1G08_G - 73,6% нулей
# Cladosporium_G - 94,0% нулей
# Lentimonas_G - 94,0% нулей
# Micromonospora_G - 93,2% нулей
# Pseudosphingobacterium_G - 93,2% нулей 
# Schizothrix LEGE 07164_G - 92,7% нулей 
# Talaromyces_G - 92,7% нулей 
# Rs-D38 termite group_G - 91,9% нулей 
# Kabatiella_G - 90,6% нулей 
# Anaerolineaceae UCG-001_G - 89,5% нулей 
# Iamia_G - 88,2% нулей 
# Thiohalocapsa_G - 87,9% нулей 
# Ellin517_G - 75,1% нулей 

```

- F-taxa

```{r}

data_wide %>% 
  select (research_ID, ends_with("_F")) %>%
  add_column(n = 1) %>% # for further counting the subjects number in each study
  group_by(research_ID) %>% 
  summarise_each (sum) %>% 
  select (research_ID, n, where (function(x) sum (x!=0) == 1)) %>%  #selecting "single study taxa"
  mutate (across(-c(1:2), function(x) x/n)) %>% 
  mutate (across(-c(1:2), function(x) round (x,3))) %>% 
  as_tibble() %>% flextable() %>% set_caption("Mean percentage of single study F-taxa")

#Determining the percentage of people in whom these taxa have not been detected
#F_taxon <- 'Iamiaceae_F'
#res_ID <- 1

#data_wide %>% 
  #select (research_ID, F_taxon) %>%
  #filter (research_ID == res_ID) %>% 
  #summarise(across (-1,
              #function (x) sum (x==0)/nrow (.) * 100)) %>% 
  #rename ("Taxon_zero_percentage, %" = F_taxon) 

# Didymellaceae_F - 44,4% нулей
# Cladosporiaceae_F - 36,1% нулей
# Trichocomaceae_F - 22,2% нулей
# type III_F - 30,4% нулей
# 09D2Z48_F - 23,9% нулей
# Aureobasidiaceae_F - 0% нулей 
# Iamiaceae_F - 2,2% нулей
  
```

- O-taxa

```{r}

data_wide %>% 
  select (research_ID, ends_with("_O")) %>%
  add_column(n = 1) %>% #for further counting the subjects number in each study
  group_by(research_ID) %>% 
  summarise_each (sum) %>% 
  select (research_ID, n, where (function(x) sum (x!=0) == 1)) %>%  #selecting "single study taxa"
  mutate (across(-c(1:2), function(x) x/n)) %>% 
  mutate (across(-c(1:2), function(x) round (x,3))) %>% 
  as_tibble() %>% flextable() %>% set_caption("Mean percentage of single study O-taxa")

#Determining the percentage of people in whom these taxa have not been detected
#O_taxon <- 'Candidatus Abawacabacteria_O'
#res_ID <- 1

#data_wide %>% 
  #select (research_ID, O_taxon) %>%
  #filter (research_ID == res_ID) %>% 
  #summarise(across (-1, function (x) sum (x==0)/nrow (.) * 100)) %>% 
  #rename ("Taxon_zero_percentage, %" = O_taxon) 

# Hypocreales_O - 41,7% нулей
# Pleosporales_O - 41,7% нулей
# Candidatus Abawacabacteria_O - 52,2% нулей
# Candidatus Peregrinibacteria_O - 52,2% нулей
# Capnodiales_O - 33,3% нулей
# Candidatus Terrybacteria_O - 39,1% нулей
# Eurotiales_O - 39,1% нулей
# Dothideales_O - 0% нулей
# eub62A3_O - 15,2% нулей
# LD1-PA32_O - 2,2% нулей
  
```

- C-taxa

```{r}

data_wide %>% 
  select (research_ID, ends_with("_C")) %>%
  add_column(n = 1) %>% #for further counting the subjects number in each study
  group_by(research_ID) %>% 
  summarise_each (sum) %>% 
  select (research_ID, n, where (function(x) sum (x!=0) == 1)) %>%  #selecting "single study taxa"
  mutate (across(-c(1:2), function(x) x/n)) %>% 
   mutate (across(-c(1:2), function(x) round (x,3))) %>% 
  as_tibble() %>% flextable() %>% set_caption("Mean percentage of single study C-taxa")

#Determining the percentage of people in whom these taxa have not been detected
#С_taxon <- 'Dothideomycetes_C'
#res_ID <- 2

#data_wide %>% 
  #select (research_ID, С_taxon) %>%
  #filter (research_ID == res_ID) %>% 
  #summarise(across (-1, function (x) sum (x==0)/nrow (.) * 100)) %>% 
  #rename ("Taxon_zero_percentage, %" = С_taxon) 

# WWE3_C - 74,4% нулей
# Eurotiomycetes_C - 19,4% нулей 
# Dothideomycetes_C - 0% нулей 
  
```

- P-taxa

**"Single study P-taxa" have not been detected**

    

## data_wide_not_batched dataset

```{r}

data_wide <- data_wide %>% 
  select (!colnames (G_only_one) [- c (1,2)]) #deleting of single study G-taxa (in this single study the taxa were present in no more than 25% of subjects)

data_wide_not_batched <- data_wide  

write_rds(data_wide, 
          file = "data/originals/data_wide_not_batched.rds")

```

# Clustering before batch effect correction

### AGNES (euclidean distance matrix)

```{r, warning=FALSE, message=FALSE}

clusters_number <- 7 #number of clusters

library(cluster)
library(factoextra)

G_scaled <- data_wide %>% 
  mutate(patient_ID = paste0("patient_", patient_ID)) %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_G")) %>% 
  scale () 

agnes <- G_scaled %>% 
  dist (method = "euclidean") %>% 
  as.matrix() %>%  
  agnes( #Agglomerative clustering
    diss = TRUE, #dissimilarity matrix
    method = "ward")

fviz_dend(agnes,
          k = clusters_number,
          rect = TRUE,
          k_colors = "jco",
          show_labels = TRUE,
          label_cols = ifelse (data_wide[agnes$order,]$Health_state == "Health", "green", "red"),
          #labels colors = Health_state
          cex = 0.2,
          main = "Cluster dengrogram based on G-taxa abundance before batch effect correction",
          ylab = "")

```

-   Comparison of the clusters

```{r, warning=FALSE, message=FALSE}

data_wide %>% 
  add_column("Cluster" = cutree(agnes, k = clusters_number)) %>% 
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p()

```

### AGNES (distance matrix for Bray-Curtis dissimilarity)

```{r, message=FALSE, warning=FALSE}

agnes2 <- data_wide %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_G")) %>% 
  vegdist(method = "bray") %>% #distance matrix for Bray-Curtis dissimilarity:
  #the Bray–Curtis dissimilarity is bounded between 0 and 1, where 0 means the two sites have the same composition , and 1 means the two sites do not share any species
  as.matrix() %>% 
  agnes( #Agglomerative clustering 
    diss = TRUE, #dissimilarity matrix
    method = "ward")

fviz_dend(agnes2, 
          cex = 0.2, k = clusters_number,
          rect = TRUE,
          k_colors = "jco",
          color_labels_by_k = FALSE,
          label_cols = ifelse (data_wide[agnes2$order,]$Health_state == "Health", "green", "red"),
          #labels colors = Health_state
          main = "Cluster dengrogram based on G-taxa abundance before batch effect correction",
          ylab = "")

```

-   Comparison of the clusters

```{r, warning=FALSE, message=FALSE}

fisher.test.simulate.p.values <- function(data, variable, by, ...) {
  result <- list()
  test_results <- stats::fisher.test(data[[variable]], data[[by]], simulate.p.value = TRUE)
  result$p <- test_results$p.value
  result$test <- test_results$method
  result
}

data_wide %>% 
  add_column("Cluster" = cutree(agnes2, k = clusters_number)) %>%
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p(test = list(all_categorical() ~ "fisher.test.simulate.p.values"))

```

### kMeans

```{r}

kmeans <- G_scaled %>% 
  kmeans(centers = clusters_number,
         iter.max = 20, nstart = 35) 

  fviz_cluster(kmeans,data = G_scaled,
               ellipse = FALSE,
               show.clust.cent = FALSE,
               geom = "point",
               main = "kMeans clustering based on G-taxa abundance before batch effect correction")

```



# Batch-effects correction

the MBECS package was used, a step-by-step actions description is available at the link <https://github.com/rmolbrich/MBECS>

```{r, message=FALSE, warning=FALSE, include=FALSE}

#devtools::install_github("rmolbrich/MBECS")
#MBECS introductionhttps://bioconductor.org/packages/release/bioc/vignettes/MBECS/inst/doc/mbecs_vignette.html
library(MBECS)

#1. Get started
#Creation of an object of class MbecData
mbec.obj <- mbecProcessInput (
  list (
    #abundance table:
    data_wide %>% 
    select (patient_ID, Archaea, Bacteria, ends_with(c("_D", "_P", "_O", "_C", "_F", "_G"))) %>%
    rename("sID" = "patient_ID") %>%
    mutate(sID = paste0 ("S", sID)) %>% 
    column_to_rownames('sID') %>% 
    as.data.frame(),
  
  #meta-data:
  data_wide %>% 
    select (any_of(colnames (combined_info))) %>% 
    rename("sID" = "patient_ID") %>% 
    mutate(sID = as.character(sID),
           sID = paste0 ("S", sID),
           research_ID = as.factor(research_ID)) %>% 
    select (sID, everything()) %>% 
    as.data.frame()          
  ))

#2. Centered log-ratio transformation of the data
mbec.obj <- mbecTransform(mbec.obj, 
                          method = "clr",
                          offset = 0.0001)

#3. Preliminary report
#mbecReportPrelim(input.obj=mbec.obj, 
                 #model.vars=c('research_ID', 'Health_state'),
                 #model.vars=c (batch effect, presumed biological effect of interest)
                 #type="otu", #which abundance matrix to use for evaluation:  'cor'/'clr'/'tss'
                 #file.name = "Batch_Preliminary_Report_otu",
                 #file.dir = "data/originals/",
                 #return.data = FALSE)
                 
```

**Preliminary report is available in /data/originals/.**

-   Correction of `research_ID` batch-effect

```{r, message=FALSE, warning=FALSE, error=FALSE}

#Run corrections
mbec.obj <- mbecRunCorrections(
  mbec.obj, 
  model.vars=c('research_ID', 'Health_state'),
#model.vars=c (batch effect, presumed biological effect of interest) 
method = "bat", #batch effect correcting algorithm:
#Batch Mean Centering (bmc) /ComBat (bat)/Remove Batch Effect (rbe)
type = "otu") #which abundance matrix to use

#Post report
#mbecReportPost(
  #input.obj=mbec.obj, 
  #model.vars=c('research_ID', 'Health_state'), #model.vars=c (batch effect, presumed biological effect of interest) 
#type="otu", # which abundance matrix to use for evaluation: clr/otu/tss
#file.name = "Batch_(research_id)_Correction_Report_otu_bat",
#file.dir = "data/originals/",
#return.data = FALSE)

library (datawizard)

#Retrieve corrrected data
ps.cor.bat <- mbecGetPhyloseq(mbec.obj, 
                          type="cor", #which type of data to add
                          label="bat") #specifies the name within the list

combined_bacteria_batched <- ps.cor.bat@otu_table %>% 
  as.data.frame() %>% 
  data_rotate (rownames	= "patient_ID") %>% 
  mutate (patient_ID = sub ("S", "", patient_ID),
          patient_ID = as.numeric(patient_ID))

data_wide_batched <- data_wide %>% 
  select (any_of(colnames (combined_info))) %>% 
  left_join(combined_bacteria_batched)

rm (combined_bacteria_batched)

data_wide <- data_wide_batched  

write_rds(data_wide, 
          file = "data/originals/data_wide.rds")

```

####Principal Component Analysis

-   before the batch effect correction

```{r, message=FALSE, warning=FALSE, error=FALSE}

plot <- mbecPCA(input.obj=mbec.obj, 
        model.vars=c('research_ID', 'Health_state'),
        type="otu", pca.axes=c(1,2), return.data = FALSE) 

ggsave("data/pictures/PCA_befor_batching.jpeg", plot = plot)
```

-   after the batch effect correction

```{r, message=FALSE, warning=FALSE, error=FALSE}

plot <- mbecPCA(input.obj=mbec.obj, 
        model.vars=c('research_ID', 'Health_state'),
        type="cor", label = "bat",
        pca.axes=c(1,2), return.data = FALSE)

ggsave("data/pictures/PCA_after_batching.jpeg", plot = plot)

```

####Heatmap of the top 10 most variable taxa

- before the batch effect correction

```{r}

mbecHeat(input.obj=mbec.obj, method = "TOP", n = 10, 
         model.vars=c('research_ID', 'Health_state'),
         center = TRUE, scale = TRUE, 
         type="otu",
         return.data = FALSE)

```

- after the batch effect correction

```{r}
mbecHeat(input.obj=mbec.obj, method = "TOP", n = 10, 
         model.vars=c('research_ID', 'Health_state'),
         center = TRUE, scale = TRUE, 
         type="cor", label = "bat", 
         return.data = FALSE)
```

### AGNES (euclidean distance matrix) after the batch effect correction

```{r, warning=FALSE, message=FALSE}

G_scaled <- data_wide_batched %>% 
  mutate(patient_ID = paste0("patient_", patient_ID)) %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_G")) %>% 
  scale () 

agnes <- G_scaled %>% 
  dist (method = "euclidean") %>%
  as.matrix() %>%  
  agnes( #gglomerative clustering
    diss = TRUE, #dissimilarity matrix
    method = "ward")

fviz_dend(agnes,
          k = clusters_number,
          rect = TRUE,
          k_colors = "jco",
          show_labels = TRUE,
          label_cols = ifelse (data_wide_batched[agnes$order,]$Health_state == "Health", "green", "red"),#labels color = Health_state
          cex = 0.2, 
          main = "Cluster dengrogram based on G-taxa abundance after batch effect correction",
          ylab = "")

```

-   Comparison of the clusters

```{r, warning=FALSE, message=FALSE}

data_wide %>% 
  add_column("Cluster" = cutree(agnes, k = clusters_number)) %>%
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p(test = list(all_categorical() ~ "fisher.test.simulate.p.values"))

```

### kMeans

```{r}

kmeans <- G_scaled %>% 
  kmeans(centers = clusters_number, 
         iter.max = 20, 
         nstart = 35) 

  fviz_cluster(kmeans,data = G_scaled,
               ellipse = FALSE,
               show.clust.cent = FALSE,
               geom = "point",
               main = "kMeans clustering based on G-taxa abundance after batch effect correction")
      
```

### AGNES (distance matrix Bray-Curtis dissimilarity)

```{r, message=FALSE, warning=FALSE}

agnes2 <- data_wide_batched %>% 
  column_to_rownames("patient_ID") %>% 
  select (ends_with("_G")) %>% 
  vegdist(method = "bray") %>%
  as.matrix() %>% 
  agnes( #Agglomerative clustering 
    diss = TRUE, #dissimilarity matrix
    method = "ward")

fviz_dend(agnes2, 
          cex = 0.2, k = clusters_number,
          rect = TRUE,
          k_colors = "jco",
          color_labels_by_k = FALSE,
          label_cols = ifelse (data_wide[agnes2$order,]$Health_state == "Health", "green", "red"),
          #labels colors = Health_state
          main = "Cluster dengrogram based on G-taxa abundance after batch effect correction",
          ylab = "")

```

- Comparison of the clusters

```{r, warning=FALSE, message=FALSE}

data_wide %>% 
  add_column("Cluster" = cutree(agnes2, k = clusters_number)) %>%
  select(any_of(colnames (combined_info)), Cluster, - patient_ID) %>% 
  tbl_summary(digits = list(all_continuous() ~ c(0, 0),
                            all_categorical() ~ c(0, 0)),
              by = Cluster) %>% 
  add_p(test = list(all_categorical() ~ "fisher.test.simulate.p.values"))

```


## bac_functions dataset

```{r}

path <- "data/raw/Bacterial group functions.xlsx"
taxon <- c ("TaxonName", "Rank")

neuromediators <- read_xlsx (path, 2) %>% 
  mutate(Destroy = ifelse(is.na (Destroy), "produce", "destroy")) %>% 
  unique() %>%
  pivot_wider(names_from = Neuromediator, values_from = Destroy)

probiotics <- read_xlsx (path, 3) %>% 
  add_column(probiotics = 1)

special_properties <- read_xlsx (path, 4) %>% 
  add_column(special_properties = 1)

vitamins <- read_xlsx (path, 5) %>% 
  pivot_wider (names_from = Vitamin, values_from = Vitamin,
               values_fn = function(x) ifelse(is.na (x), NA, 1))

habbits <- read_xlsx (path, 7) %>%
  unique() %>% #удаление повторяющихся строк 
  pivot_wider(names_from = Habbit, values_from = Habit_state)

bac_functions <- read_xlsx (path, 1) %>% #Патогены и нежелательные
  full_join(neuromediators, by = taxon) %>% #Нейромедиаторы
  full_join(probiotics, by = taxon) %>% #Пробиотики
  full_join(special_properties, by = taxon) %>% #С особыми свойствами
  full_join(vitamins, by = taxon) %>%  #Витамины
  full_join(read_xlsx (path, 6), by = taxon) %>% #Продуценты КЦДК
  full_join(habbits, by = taxon) %>% #Вредные привычки
  
  unite("Taxon", TaxonName, Rank, sep = "_") %>% 
  filter (Taxon != "Blautia obeum_S") %>% #для данного таксона противоречивая информация в Продуценты КЦЖК
  mutate_all(as.factor)

rm (path, taxon, neuromediators, probiotics, special_properties, vitamins, habbits)
```

## data_long

```{r data_long, warning=FALSE}

# Сonverting the data_wide to a long format
data_long <- data_wide %>% 
  pivot_longer(ends_with(c("_D", "_P", "_O", "_C", "_F", "_G")),
               names_to = "Taxon", values_to = "Percentage") %>% 
  left_join (bac_functions, by = "Taxon") #combining with `bac_functions` datasets

write_rds(data_long, 
          file = "data/originals/data_long.rds",
          compress = "gz") 

#Creation a long dataset for each taxon
G_long <- data_long %>% subset(grepl("_G", Taxon)) 
F_long <- data_long %>% subset(grepl("_F", Taxon))
C_long <- data_long %>% subset(grepl("_C", Taxon))
O_long <- data_long %>% subset(grepl("_O", Taxon))
P_long <- data_long %>% subset(grepl("_P", Taxon))

write_rds(G_long, 
          file = "data/originals/G_long.rds", "gz") 
write_rds(F_long, 
          file = "data/originals/F_long.rds", "gz") 
write_rds(C_long, 
          file = "data/originals/C_long.rds", "gz") 
write_rds(O_long, 
          file = "data/originals/O_long.rds", "gz") 
write_rds(P_long, 
          file = "data/originals/P_long.rds", "gz") 

```


# Analysis

## Сравнение среднего общего содержания G_таксонов с особыми свойствами

```{r, message=FALSE}

comparison <- function (special_data, special_property) {
#vector of the G_taxa names with special properties:  
    bac_names <-  special_data %>% 
      subset(grepl("_G", Taxon)) %>% .$Taxon
#number of the G_taxa in data_wide
    number_of_taxons <- data_wide %>% 
      select(patient_ID, Health_state, any_of(bac_names)) %>% 
      ncol() - 2
# t-test
t <- data_wide %>% 
  select(patient_ID, Health_state, any_of(bac_names)) %>% 
  pivot_longer(ends_with("_G"),
               names_to = "Taxon", values_to = "Percentage") %>% 
  group_by(patient_ID, Health_state) %>% 
  summarise(across(Percentage, sum)) %>% 
  ungroup() %>% 
  t.test (Percentage ~ Health_state, .)
#a tibble with results
tibble("G_taxa" = special_property, 
       "Number of taxa" = number_of_taxons,
       "Mean of total percentage in IBS" = t$estimate["mean in group Disease"],
       "Mean of total percentage in healthy" = t$estimate["mean in group Health"],
       "95% CI_1" = t$conf.int[1],
       "95% CI_2" = t$conf.int[2],
       "p.unadjusted" = t$p.value)
}


comparison_in_total <- rbind(
    comparison (bac_functions %>% filter (Серотонин == "produce"), "Serotonin producing"),
    comparison (bac_functions %>% filter (Серотонин == "destroy"), "Serotonin destroying"),
    comparison (bac_functions %>% filter (Ацетилхолин == "produce"), "Acetylcholine producing"),
    comparison (bac_functions %>% filter (ГАМК == "produce"), "GABA producing"),
    comparison (bac_functions %>% filter (ГАМК == "destroy"), "GABA destroying"),
    comparison (bac_functions %>% filter (Дофамин == "produce"), "Dopamine producing"),
    comparison (bac_functions %>% filter (Дофамин == "destroy"), "Dopamine destroying"),
    comparison (bac_functions %>% filter (probiotics == 1), "Probiotics"),
    comparison (bac_functions %>% filter (special_properties == 1), "Special_properties"),
    comparison (bac_functions %>% filter (Gases == 1), "Gases producing"),
    comparison (bac_functions %>% filter (Oral == 1), "Oral"),
    comparison (bac_functions %>% filter (Inflammatory == 1), "Inflammatory"),
    comparison (bac_functions %>% filter (Bacteria_category == "Патоген"), "Pathogens"),
    comparison (bac_functions %>% filter (Bacteria_category == "Условно-нормальный"), "Conditionally normal"),
    comparison (bac_functions %>% filter (A == 1), "Vitamin A producing"),
    comparison (bac_functions %>% filter (B1 == 1), "Vitamin B1 producing"),
    comparison (bac_functions %>% filter (B12 == 1), "Vitamin B12 producing"),
    comparison (bac_functions %>% filter (B2 == 1), "Vitamin B2 producing"),
    comparison (bac_functions %>% filter (B3 == 1), "Vitamin B3 producing"),
    comparison (bac_functions %>% filter (B5 == 1), "Vitamin B5 producing"),
    comparison (bac_functions %>% filter (B6 == 1), "Vitamin B6 producing"),
    comparison (bac_functions %>% filter (B7 == 1), "Vitamin B7 producing"),
    comparison (bac_functions %>% filter (B9 == 1), "Vitamin B9 producing"),
    comparison (bac_functions %>% filter (D3 == 1), "Vitamin D3 producing"),
    comparison (bac_functions %>% filter (K2 == 1), "Vitamin K2 producing"),
    comparison (bac_functions %>% filter (Ацетат == 1), "Acetate producing"),
    comparison (bac_functions %>% filter (Пропионат == 1), "Propionate producing"),
    comparison (bac_functions %>% filter (`Масляная кислота` == 1), "Butyrate producing"),
    comparison (bac_functions %>% filter (Кофе == "Увеличена"), "Increase with coffee"),
    comparison (bac_functions %>% filter (Курение == "Увеличена"), "Increase with smoking"),
    comparison (bac_functions %>% filter (Курение == "Уменьшена"), "Derease with smoking"),
    comparison (bac_functions %>% filter (Алкоголь == "Увеличена"), "Increase with alcohol"),
    comparison (bac_functions %>% filter (Алкоголь == "Уменьшена"), "Derease with alcohol")
    ) %>% 
  filter (`Number of taxa` >= 3) %>% 
  add_column(.before = "95% CI_1", "Difference in means" = .$"Mean of total percentage in IBS" - .$"Mean of total percentage in healthy") %>% 
  mutate (across (c ("Mean of total percentage in IBS", "Mean of total percentage in healthy", "Difference in means", "95% CI_1", "95% CI_2"), function (x) round (x,2)),
          p.unadjusted = round (p.unadjusted, 3),
          p.value.holm = p.adjust(p.unadjusted, "holm")) %>% 
  unite("95% CI_1", "95% CI_2", col = "95% CI", sep = ":") %>% 
  arrange(desc (abs (.$"Difference in means")))

write_rds(comparison_in_total, 
          file = "data/originals/comparison_in_total.rds") 

comparison_in_total %>% 
  mutate (p.unadjusted = ifelse(p.unadjusted < 0.001, "< 0.001", p.unadjusted),
          p.value.holm = ifelse(p.value.holm < 0.001, "< 0.001", p.value.holm)) %>%
  flextable() %>% theme_box() %>% 
  align(align = "center", part = "all") %>% 
  flextable::footnote (i = 1, j = 7, value = as_paragraph (c ("Welch Two Sample t-test")),
            ref_symbols = "1", part = "header") %>% 
  set_caption("Results of IBS/healthy people comparison of means of total percentage of G-taxa with special properties")


```

## Факторный анализ

-   Проведем множественное сравнение каждого таксона из `combined_bacteria` с по группе `Health_state` из `combined_info` без учета таксономического уровня.

```{r}
# Создание нового датасета для сохранения результатов
result_dataset <- data.frame(
  Variable_Name = character(),
  Test_Type = character(),
  P_Value = numeric(),
  Normal_Distribution = character(),
  stringsAsFactors = FALSE
)

alpha = 0.05

# Объединяем датасеты по patient_id 
combined_data <- data_wide %>%
  select(Health_state,
    ends_with(c("_D", "_P", "_O", "_C", "_F", "_G")))

combined_bacteria_clean <- combined_data

# Получаем список переменных из датасета combined_bacteria, исключая "patient_ID"
values_to_exclude <- c("patient_ID", "Seq_date", "Age")
variable_names <- setdiff(names(combined_bacteria_clean), values_to_exclude)

# Проходим по каждой переменной
for (variable in variable_names) {
  # Фильтрация данных (исключаем строки с NA и 0 в текущей переменной)
  filtered_data <- combined_data[!is.na(combined_data[[variable]]) & combined_data[[variable]] != 0, ]
  #print(variable)
  #print(filtered_data)

  # Проверим что датасет filtered_data не пустой и что количество групп сравнения более 1, в нашем случае их 2 :)
  if (nrow(filtered_data) > 0 & length(unique(filtered_data$Health_state)) > 1) {
    
  # Check if there is sufficient variability in the data
  if (length(unique(filtered_data$Health_state)) > 1) {
    # Проверка на нормальность
    shapiro_test_result <- try(shapiro.test(filtered_data[[variable]]), silent = TRUE)
    if (inherits(shapiro_test_result, "try-error")) {
      warning(paste("Skipping Shapiro-Wilk test for variable", variable, "due to an error."))
      next
    }
    p_value_shapiro <- shapiro_test_result$p.value

    # Выбор соответствующего статистического теста
    if (p_value_shapiro > 0.05) {
      # Если нормальное распределение, провести дисперсионный анализ
      model <- aov(filtered_data[[variable]] ~ Health_state, data = filtered_data)
      summary_list <- summary(model)
      test_type <- "ANOVA"
    } else {
      # Если не нормальное распределение, использовать тест Краскела-Уоллиса
      tryCatch({
        model <- kruskal.test(filtered_data[[variable]] ~ Health_state, data = filtered_data)
        test_type <- "Kruskal-Wallis"
      }, error = function(e) {
        warning(paste("Skipping Kruskal-Wallis test for variable", variable, "due to an error:", conditionMessage(e)))
        next
      })
    }

    # Добавление результатов выбранного теста в датасет
    result_dataset <- rbind(result_dataset, 
                            data.frame(Variable_Name = variable,
                                       Test_Type = test_type,
                                       P_Value = ifelse(test_type == "ANOVA", summary_list[[1]]$"Pr(>F)"[1], model$p.value),
                                       Normal_Distribution = ifelse(p_value_shapiro > 0.05, "Yes", "No")))
  } else {
    # If there is no variability, skip the tests
    warning(paste("Skipping tests for variable", variable, "as there is not enough variability in the data."))
  }
  }}

# Добавление столбца с поправкой Бонферрони
result_dataset$Adjusted_P_Value_Bonferroni <- p.adjust(result_dataset$P_Value, method = "bonferroni")

# Добавление столбца с поправкой Холма
result_dataset$Adjusted_P_Value_Holm <- p.adjust(result_dataset$P_Value, method = "holm")

# Добавление столбца с поправкой Бенджамини-Хохберга
result_dataset$Adjusted_P_Value_BH <- p.adjust(result_dataset$P_Value, method = "BH")

result_dataset$test_pass = ifelse(result_dataset$Adjusted_P_Value_Bonferroni < alpha & result_dataset$Adjusted_P_Value_Holm < alpha & result_dataset$Adjusted_P_Value_BH < alpha, "Y", "N")

result_dataset_pass <- result_dataset %>% filter(test_pass == "Y")

# Вывод результатов
print(result_dataset_pass)

```

-   Посмотрим на данные здоровых людей и людей с СРК как на многомерный вектор по всем таксонам и группам

```{r, warning=FALSE}

combined_bacteria_G <- combined_bacteria_clean %>%
  select(Health_state, ends_with("_G"))

d <- dist(combined_bacteria_G) # euclidean distances between the rows
fit <- cmdscale(d,eig=TRUE, k=2) # k is the number of dim

df_mds <- data.frame(
  x = fit$points[,1],
  y = fit$points[,2]
  )  

df_full <- cbind(df_mds, combined_info) %>% mutate(Health_state_n = case_when(Health_state == "Health"  ~ 0,
                                                                              Health_state == "Disease" ~ 1))

ggplot(df_full, aes(x = x, y = y, color = Health_state)) +
  geom_point() +
  theme_bw() +
  ggtitle("Распределение вектора таксонов в зависимости от группы пациентов")
```

-   Используя метод пермутаций проверим отличаются ли группы в зависимомти от Health_state

```{r permanova}

adonis2(d ~ Health_state_n, data = df_full)

```

## Тест Манна-Уитни для сравнения каждого таксона между больными и здоровыми

-   после округления всех значений **до целого**

```{r}

Wilcox_comparison_round_0 <- data_wide %>% 
  select(Health_state, Archaea, Bacteria,
         ends_with(c("_D", "_P", "_O", "_C", "_F", "_G"))) %>% 
  mutate(across (where (is.numeric), function (x) round (x,0))) %>% 
  summarise_if (is.numeric, function (x) (wilcox.test(x ~ .$Health_state)$p.value)) %>% 
  pivot_longer(everything()) %>% 
  rename (Taxon = name, p_value = value) %>% 
  filter (p_value <= 0.05 ) %>% 
  arrange(p_value) %>% 
  add_column(p_value_holm = p.adjust(.$p_value, "holm")) %>% 
  add_column(p_value_BH = p.adjust(.$p_value, "BH"))

 rbind (
   "Количество значимо различающихся таксонов по p_value" = nrow (Wilcox_comparison_round_0),
 "Количество значимо различающихся таксонов по p_value_holm" = nrow (Wilcox_comparison_round_0 %>% filter (p_value_holm <= 0.05 )),
 "Количество значимо различающихся таксонов по p_value_BH" = nrow (Wilcox_comparison_round_0 %>% filter (p_value_BH <= 0.05 ))
 )
 
```

-   после округления всех значений **до десятых**

```{r}

Wilcox_comparison_round_1 <- data_wide %>% 
  select(Health_state, Archaea, Bacteria,
         ends_with(c("_D", "_P", "_O", "_C", "_F", "_G"))) %>% 
  mutate(across (where (is.numeric), function (x) round (x,1))) %>% 
  summarise_if (is.numeric, function (x) (wilcox.test(x ~ .$Health_state)$p.value)) %>% 
  pivot_longer(everything()) %>% 
  rename (Taxon = name, p_value = value) %>% 
  filter (p_value <= 0.05 ) %>% 
  arrange(p_value) %>% 
  add_column(p_value_holm = p.adjust(.$p_value, "holm")) %>% 
  add_column(p_value_BH = p.adjust(.$p_value, "BH"))

 rbind (
   "Количество значимо различающихся таксонов по p_value" = nrow (Wilcox_comparison_round_1),
 "Количество значимо различающихся таксонов по p_value_holm" = nrow (Wilcox_comparison_round_1 %>% filter (p_value_holm <= 0.05 )),
 "Количество значимо различающихся таксонов по p_value_BH" = nrow (Wilcox_comparison_round_1 %>% filter (p_value_BH <= 0.05 ))
 )
 
```

-   после округления всех значений **до сотых**

```{r}

Wilcox_comparison_round_2 <- data_wide %>% 
  select(Health_state, Archaea, Bacteria,
         ends_with(c("_D", "_P", "_O", "_C", "_F", "_G"))) %>% 
  mutate(across (where (is.numeric), function (x) round (x,2))) %>% 
  summarise_if (is.numeric, function (x) (wilcox.test(x ~ .$Health_state)$p.value)) %>% 
  pivot_longer(everything()) %>% 
  rename (Taxon = name, p_value = value) %>% 
  filter (p_value <= 0.05 ) %>% 
  arrange(p_value) %>% 
  add_column(p_value_holm = p.adjust(.$p_value, "holm")) %>% 
  add_column(p_value_BH = p.adjust(.$p_value, "BH"))

 rbind (
   "Количество значимо различающихся таксонов по p_value" = nrow (Wilcox_comparison_round_2),
 "Количество значимо различающихся таксонов по p_value_holm" = nrow (Wilcox_comparison_round_2 %>% filter (p_value_holm <= 0.05 )),
 "Количество значимо различающихся таксонов по p_value_BH" = nrow (Wilcox_comparison_round_2 %>% filter (p_value_BH <= 0.05 ))
 )
 
```

## GLM метод для нулей

```{r labels for Tweedie GLM model, message=FALSE}

library("haven")
library("ResourceSelection")  ## Package to perform the Hosmer-Lemeshow GOF test
library("survey")
library("prediction")
library("margins")
library("ggeffects")
library("sjPlot")
library("statmod")
#devtools::install_github("strengejacke/strengejacke")
#install.packages(c("haven", "ResourceSelection", "survey", "prediction", "margins", "ggeffects", "sjPlot", "statmod"))

```

```{r}
options(survey.lonely.psu = 'adjust')
start_values <- c(0, 0, 1)
```

## G - Genus (Род)

```{r warning=FALSE}

analyze_taxon <- function(taxon_name, data) {
  tryCatch(
    {
      data_filtered <- data %>%
        filter(Taxon == taxon_name) %>%
        select(patient_ID, Health_state, Percentage, Age_range, research_ID) %>%
        mutate(Health_state_num = ifelse(Health_state == "Health", 0, 1)) # для упрацения интерпритации процентов
      
      mepsdsgn = svydesign(
        id = ~patient_ID,
        strata = ~research_ID,
        weights = NULL,
        data = data_filtered,
        nest = TRUE)
      
      start_values <- c(0, 0, 1)
      
      model <- svyglm(Percentage ~ Health_state_num + research_ID,
                      mepsdsgn,
                      family = tweedie(var.power = 2, link.power = 1),
                      start = start_values)
      
      summary_table <- summary(model)
      
      tidy_output <- tidy(model)
      
      result_table1 <- tidy_output %>%
        filter(term == "Health_state_num") %>%
        select(estimate, p.value)
      
      result_table2 <- as.data.frame(confint(model)["Health_state_num", ])
      
      result_table2_transposed <- t(result_table2)
      
      final_result_table_transposed <- bind_cols(result_table1, result_table2_transposed) %>%
        select(estimate, `2.5 %`, `97.5 %`, p.value)
      
      final_result_table_transposed$Taxon <- taxon_name
      
      return(final_result_table_transposed)
    },
    error = function(e) {
      # Обработка ошибки (можно добавить сообщение или просто вернуть NULL)
      # cat("Error in analyze_taxon for Taxon:", taxon_name, "\n")
      return(NULL)
    }
  )
}

# Применение функции ко всем таксонам
unique_taxa <- unique(G_long$Taxon)

result_list <- lapply(unique_taxa, function(taxon) {
  analyze_result <- analyze_taxon(taxon, G_long)
  if (!is.null(analyze_result)) {
    return(analyze_result)
  } else {
    return(data.frame())  # Вернуть пустой data.frame, чтобы не влиять на bind_rows
  }
})

# Объединение результатов в один dataframe
final_result_df <- bind_rows(result_list) %>%
  mutate(estimate = round(estimate, 3),
         `2.5 %` = round(`2.5 %`, 4),
         `97.5 %` = round(`97.5 %`, 4)
         )

# Коррекция на множественные сравнения по методу Холма
final_result_df$p.adjusted <- round(p.adjust(final_result_df$p.value, method = "holm"),3)

# Фильтрация только статистически значимых результатов
significant_results_G <- final_result_df %>%
  filter(p.adjusted < 0.05) %>%  arrange(desc(abs(estimate)))

 #install.packages("knitr")
 #install.packages("kableExtra")

# Загрузка библиотек
library(knitr)
library(kableExtra)

# Ваш код

# Вывод таблички
cat("Статистически значимые результаты:\n")
kable(significant_results_G, "html") %>%
  kable_styling(full_width = F)
```

## F - Family (семейство)

```{r warning=FALSE}

# Применение функции ко всем таксонам
unique_taxa <- unique(F_long$Taxon)

result_list <- lapply(unique_taxa, function(taxon) {
  analyze_result <- analyze_taxon(taxon, F_long)
  if (!is.null(analyze_result)) {
    return(analyze_result)
  } else {
    return(data.frame())  # Вернуть пустой data.frame, чтобы не влиять на bind_rows
  }
})

# Объединение результатов в один dataframe
final_result_df <- bind_rows(result_list) %>%
  mutate(estimate = round(estimate, 3),
         `2.5 %` = round(`2.5 %`, 4),
         `97.5 %` = round(`97.5 %`, 4)
         )

# Коррекция на множественные сравнения по методу Холма
final_result_df$p.adjusted <- round(p.adjust(final_result_df$p.value, method = "holm"),3)

# Фильтрация только статистически значимых результатов
significant_results_F <- final_result_df %>%
  filter(p.adjusted < 0.05) %>%  arrange(desc(abs(estimate)))

# Вывод таблички
cat("Статистически значимые результаты:\n")
kable(significant_results_F, "html") %>%
  kable_styling(full_width = F)
```

## C - Class (класс)

```{r warning=FALSE}
# Применение функции ко всем таксонам
unique_taxa <- unique(C_long$Taxon)

result_list <- lapply(unique_taxa, function(taxon) {
  analyze_result <- analyze_taxon(taxon, C_long)
  if (!is.null(analyze_result)) {
    return(analyze_result)
  } else {
    return(data.frame())  # Вернуть пустой data.frame, чтобы не влиять на bind_rows
  }
})

# Объединение результатов в один dataframe
final_result_df <- bind_rows(result_list) %>%
  mutate(estimate = round(estimate, 3),
         `2.5 %` = round(`2.5 %`, 4),
         `97.5 %` = round(`97.5 %`, 4)
         )

# Коррекция на множественные сравнения по методу Холма
final_result_df$p.adjusted <- round(p.adjust(final_result_df$p.value, method = "holm"),3)

# Фильтрация только статистически значимых результатов
significant_results_C <- final_result_df %>%
  filter(p.adjusted < 0.05) %>%  arrange(desc(abs(estimate)))

# Вывод таблички
cat("Статистически значимые результаты:\n")
kable(significant_results_C, "html") %>%
  kable_styling(full_width = F)
```

## O - Order (порядок)

```{r warning=FALSE}
# Применение функции ко всем таксонам
unique_taxa <- unique(O_long$Taxon)

result_list <- lapply(unique_taxa, function(taxon) {
  analyze_result <- analyze_taxon(taxon, O_long)
  if (!is.null(analyze_result)) {
    return(analyze_result)
  } else {
    return(data.frame())  # Вернуть пустой data.frame, чтобы не влиять на bind_rows
  }
})

# Объединение результатов в один dataframe
final_result_df <- bind_rows(result_list) %>%
  mutate(estimate = round(estimate, 3),
         `2.5 %` = round(`2.5 %`, 4),
         `97.5 %` = round(`97.5 %`, 4)
         )

# Коррекция на множественные сравнения по методу Холма
final_result_df$p.adjusted <- round(p.adjust(final_result_df$p.value, method = "holm"),3)

# Фильтрация только статистически значимых результатов
significant_results_O <- final_result_df %>%
  filter(p.adjusted < 0.05) %>%  arrange(desc(abs(estimate)))

# Вывод таблички
cat("Статистически значимые результаты:\n")
kable(significant_results_O, "html") %>%
  kable_styling(full_width = F)
```

## P - Phylum (тип)

```{r warning=FALSE}
# Применение функции ко всем таксонам
unique_taxa <- unique(P_long$Taxon)

result_list <- lapply(unique_taxa, function(taxon) {
  analyze_result <- analyze_taxon(taxon, P_long)
  if (!is.null(analyze_result)) {
    return(analyze_result)
  } else {
    return(data.frame())  # Вернуть пустой data.frame, чтобы не влиять на bind_rows
  }
})

# Объединение результатов в один dataframe
final_result_df <- bind_rows(result_list) %>%
  mutate(estimate = round(estimate, 3),
         `2.5 %` = round(`2.5 %`, 4),
         `97.5 %` = round(`97.5 %`, 4)
         )

# Коррекция на множественные сравнения по методу Холма
final_result_df$p.adjusted <- round(p.adjust(final_result_df$p.value, method = "holm"),3)

# Фильтрация только статистически значимых результатов
significant_results_P <- final_result_df %>%
  filter(p.adjusted < 0.05) %>%  arrange(desc(abs(estimate)))

# Вывод таблички
cat("Статистически значимые результаты:\n")
kable(significant_results_P, "html") %>%
  kable_styling(full_width = F)
```

## Распределения таксонов G(Genus - Род)

#### Гистограмма по количеству пациентов (Здоров - СРК)

```{r}
create_and_plot_taxon_groups <- function(filter_pattern, step_size, dataset_name) {
  
  # Получаем уникальные таксоны, удовлетворяющие условиям
  unique_taxa <- Wilcox_comparison_round_2 %>%
    subset(grepl(filter_pattern, Taxon)) %>%
    filter(p_value_holm < 0.05) %>%
    distinct(Taxon)
  
  # Разбиваем уникальные таксоны на группы по step_size
  taxon_groups <- split(unique_taxa, rep(1:ceiling(nrow(unique_taxa) / step_size), each = step_size, length.out = nrow(unique_taxa)))
  
  # Проходим по группам и строим графики
  for (i in seq_along(taxon_groups)) {
    current_taxa <- taxon_groups[[i]]
    
    current_dataset <- get(dataset_name)  # Получаем датасет по его имени
    
    G_long_filtered <- current_dataset %>%
      filter(Taxon %in% current_taxa$Taxon & Percentage > 0) %>%
      group_by(Health_state, Taxon) %>%
      summarise(Count = n(), .groups = "drop")
    
    bar_plot <- ggplot(G_long_filtered, aes(x = Health_state, y = Count, fill = Health_state == "Disease")) +
      geom_bar(position = "dodge", color = "black", stat = "identity") +
      scale_fill_manual(values = c("skyblue", "red"), guide = FALSE) +
      labs(title = paste("Гистограмма для таксонов", (i - 1) * step_size + 1, "до", min(i * step_size, nrow(unique_taxa)), "в разрезе Health_state"),
           x = "Статус пациента",
           y = "Количество пациентов, у которых обнаружен данный таксон") +
      coord_flip() +
      facet_wrap(~Taxon, scales = "free_y", ncol = 2, shrink = 0.7) +  # Уменьшение пространства между фасетами
      theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5),  # Поворот текста на оси X и уменьшение шрифта
            axis.text.y = element_text(hjust = 1, size = 5),
            strip.text = element_text(size = 5))  # Уменьшение шрифта для названия фасет
    
    print(bar_plot)  # Отображение графика на экране
    
  }
}

# Пример вызова функции с передачей "_G" в качестве аргумента и названия датасета "G_long"
create_and_plot_taxon_groups("_G", 18, "G_long")

```

### график солнышко

```{r}
create_and_plot_circular_diagrams <- function(dataset, filter_pattern, step_size, filename) {
  
  # Получаем уникальные таксоны, удовлетворяющие условиям
  unique_taxa <- Wilcox_comparison_round_2 %>%
    subset(grepl(filter_pattern, Taxon)) %>%
    filter(p_value_holm < 0.05) %>%
    distinct(Taxon)
  
  # Разбиваем уникальные таксоны на группы по step_size
  taxon_groups <- split(unique_taxa, rep(1:ceiling(nrow(unique_taxa) / step_size), each = step_size, length.out = nrow(unique_taxa)))
  
  # Проходим по группам и строим графики
  for (i in seq_along(taxon_groups)) {
    current_taxa <- taxon_groups[[i]]
    
    G_long_filtered <- dataset %>%
      filter(Taxon %in% current_taxa$Taxon & Percentage > 0) %>%
      group_by(Health_state, Taxon) %>%
      summarise(Count = n(), .groups = "drop")
    
    # Добавляем строки с Count = 0 для всех комбинаций Health_state и Taxon
    G_long_filtered <- G_long_filtered %>%
      complete(Health_state, Taxon, fill = list(Count = 0))
    
    data_id <- G_long_filtered %>% filter(G_long_filtered$Health_state == "Disease") %>%
      mutate(id = row_number()) %>% 
      select(Taxon, id)
    
    G_long_filtered <- left_join(G_long_filtered, data_id, by = "Taxon")
    
    labels_data <- G_long_filtered %>% filter(Health_state == "Disease")
    number_of_bars <- nrow(labels_data)
    
    #Вычислим углы для лейбла каждого барра
    labels_data$angel <- 90 - 360 * (labels_data$id-0.5) / number_of_bars
    
    # Добавим горизонтольную регулировку
    labels_data <- labels_data %>%
      mutate(hjust = ifelse(angel < -90, 1, 0))
    
    # Перевернем лейбл в зависимости от "полушария"
    labels_data <- labels_data %>%
      mutate(angel = ifelse(angel < -90, angel + 180, angel))
    
    # Круговая диаграмма для объединенного датасета
    p <- ggplot(data = G_long_filtered, mapping = aes(x = id, y = Count, fill = Health_state)) + 
      geom_bar(stat = "identity", position = "stack") + 
      ylim(-150, 500) +
      
      # Добавляем кастомную тему
      theme_minimal(base_size = 8) +
      theme(axis.text   = element_blank(),
            axis.title  = element_blank(),
            panel.grid  = element_blank(),
            plot.margin = unit(rep(-1, 6), "cm")) +
      coord_polar(start = 0)+
      geom_text(data = labels_data,
                aes(x = id, y = Count,
                    label = Taxon,
                    hjust = hjust),
                color = "black",
                fontface = "bold",
                alpha = 0.9,
                size = 1.5,
                angle = labels_data$angel,
                inherit.aes = FALSE) +
      # Добавляем горизонтальные линии сетки
      geom_hline(yintercept = seq(0, 300, by = 50),
                 linetype = "dotted",
                 color = "gray",
                 size = 0.5) +
      # Добавляем значения рядом с линиями сетки
      annotate("text", x = 1.2, y = seq(0, 300, by = 50),
               label = seq(0, 300, by = 50),
               color = "black",
               size = 3,
               alpha = 40,
               hjust = 0)
    
    p <- p + annotate("text", x = 0.5, y = 490, label = "Сотношение здоровых пациентов и пациентов с СРК",
                      size = 5, color = "black", fontface = "bold", hjust = 0.5)
    
    # Сформируем имя файла для сохранения
    current_filename <- paste0(filename, "_", i, ".png")
    
    # Сохраняем график под уникальным именем
    ggsave(current_filename, p, width = 10, height = 8)
    
    print(p)
  }
}

# Пример вызова функции
create_and_plot_circular_diagrams(G_long, "_G", 40, "output_plot")

```

#### Боксплот по возрасту

```{r}
create_and_plot_boxplots <- function(G_long, filter_pattern, step_size, x_var, title) {
  
  # Получаем уникальные таксоны, удовлетворяющие условиям
  unique_taxa <- Wilcox_comparison_round_2 %>%
    subset(grepl(filter_pattern, Taxon)) %>%
    filter(p_value_holm < 0.05) %>%
    distinct(Taxon)
  
  # Разбиваем уникальные таксоны на группы по step_size
  taxon_groups <- split(unique_taxa, rep(1:ceiling(nrow(unique_taxa) / step_size), each = step_size, length.out = nrow(unique_taxa)))
  
  # Проходим по группам и строим боксплоты
  for (i in seq_along(taxon_groups)) {
    current_taxa <- taxon_groups[[i]]
    
    G_long_filtered <- G_long %>%
      filter(Taxon %in% current_taxa$Taxon & Percentage > 0)
    
    # Создаем формулу для переменной x_var
    formula <- as.formula(paste("Age ~", x_var))
    
    # Строим боксплот
    box_plot <- ggplot(G_long_filtered, aes_string(x = x_var, y = "Age", fill = "Health_state")) +
      geom_boxplot() +
      labs(title = paste(title),
           x = x_var,
           y = "Age") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),  # Уменьшаем размер шрифта для подписей Taxon
            axis.title.x = element_blank(),  # Убираем название оси X
            legend.position = "bottom") +  # Перемещаем легенду вниз
      scale_fill_manual(values = c("red", "skyblue")) +
      facet_grid(~Taxon, scales = "free_y", space = "free")  # Используем facet_grid вместо facet_wrap
    
    # Отображаем график на экране
    print(box_plot)
  }
}

# Пример вызова функции с Health_state в качестве x_var
create_and_plot_boxplots(G_long, "_G", 4, "Health_state", "Боксплоты для таксонов по статусу: Здоров/СРК")

```

### Боксплот по возросту и полу

```{r}
create_and_plot_boxplots(G_long, "_G", 3, "interaction(Health_state, Sex)", "Боксплоты для таксона (Пол + статус заболевания)")
```

### Боксплот по возросту и статусу курения

```{r}
create_and_plot_boxplots(G_long, "_G", 3, "interaction(Health_state, Smoking)", "Боксплоты для таксона (Статус курения + статус заболевания)")
```

### Боксплот по возросту и статусу употребления алкоголя

```{r}
create_and_plot_boxplots(G_long, "_G", 3, "interaction(Health_state, Alcohol)", "Боксплоты для таксона (Статус употребления алкоголя + статус заболевания)")
```

## Распределения таксонов F Family(семейство)

#### Гистограмма по количеству пациентов (Здоров - СРК)

```{r}
create_and_plot_taxon_groups("_F", 18, "F_long")
```

### Круговая столбчатая диаграмма для отобрадения отношения здоровых пациентов и пациентов с СРК

```{r}
create_and_plot_circular_diagrams(F_long, "_F", 40, "F_output_plot")
```

#### Боксплот по возрасту

```{r}
create_and_plot_boxplots(F_long, "_F", 4, "Health_state", "Боксплоты для таксонов по статусу: Здоров/СРК")
```

### Боксплот по возросту и полу

```{r}
create_and_plot_boxplots(F_long, "_F", 3, "interaction(Health_state, Sex)", "Боксплоты для таксона (Пол + статус заболевания)")
```

### Боксплот по возросту и статусу курения

```{r}
create_and_plot_boxplots(F_long, "_F", 3, "interaction(Health_state, Smoking)", "Боксплоты для таксона (Статус курения + статус заболевания)")
```

### Боксплот по возросту и статусу употребления алкоголя

```{r}
create_and_plot_boxplots(F_long, "_F", 3, "interaction(Health_state, Alcohol)", "Боксплоты для таксона (Статус употребления алкоголя + статус заболевания)")
```

## Распределения таксонов C - Class (класс)

#### Гистограмма по количеству пациентов (Здоров - СРК)

```{r}
create_and_plot_taxon_groups("_C", 18, "C_long")
```

### Круговая столбчатая диаграмма для отобрадения отношения здоровых пациентов и пациентов с СРК

```{r}
create_and_plot_circular_diagrams(C_long, "_C", 40, "F_output_plot")
```

#### Боксплот по возрасту

```{r}
create_and_plot_boxplots(C_long, "_C", 4, "Health_state", "Боксплоты для таксонов по статусу: Здоров/СРК")
```

### Боксплот по возросту и полу

```{r}
create_and_plot_boxplots(C_long, "_C", 3, "interaction(Health_state, Sex)", "Боксплоты для таксона (Пол + статус заболевания)")
```

### Боксплот по возросту и статусу курения

```{r}
create_and_plot_boxplots(C_long, "_C", 3, "interaction(Health_state, Smoking)", "Боксплоты для таксона (Статус курения + статус заболевания)")
```

### Боксплот по возросту и статусу употребления алкоголя

```{r}
create_and_plot_boxplots(C_long, "_C", 3, "interaction(Health_state, Alcohol)", "Боксплоты для таксона (Статус употребления алкоголя + статус заболевания)")
```

## Распределения таксонов O - Order (порядок)

#### Гистограмма по количеству пациентов (Здоров - СРК)

```{r}
create_and_plot_taxon_groups("_O", 18, "O_long")
```

### Круговая столбчатая диаграмма для отобрадения отношения здоровых пациентов и пациентов с СРК

```{r}
create_and_plot_circular_diagrams(O_long, "_O", 30, "F_output_plot")
```

#### Боксплот по возрасту

```{r}
create_and_plot_boxplots(O_long, "_O", 4, "Health_state", "Боксплоты для таксонов по статусу: Здоров/СРК")
```

### Боксплот по возросту и полу

```{r}
create_and_plot_boxplots(O_long, "_O", 3, "interaction(Health_state, Sex)", "Боксплоты для таксона (Пол + статус заболевания)")
```

### Боксплот по возросту и статусу курения

```{r}
create_and_plot_boxplots(O_long, "_O", 3, "interaction(Health_state, Smoking)", "Боксплоты для таксона (Статус курения + статус заболевания)")
```

### Боксплот по возросту и статусу употребления алкоголя

```{r}
create_and_plot_boxplots(O_long, "_O", 3, "interaction(Health_state, Alcohol)", "Боксплоты для таксона (Статус употребления алкоголя + статус заболевания)")
```

## Распределения таксонов P - Phylum (тип)

#### Гистограмма по количеству пациентов (Здоров - СРК)

```{r}
create_and_plot_taxon_groups("_P", 18, "P_long")
```

### Круговая столбчатая диаграмма для отобрадения отношения здоровых пациентов и пациентов с СРК

```{r}
create_and_plot_circular_diagrams(P_long, "_P", 30, "P_output_plot")
```

#### Боксплот по возрасту

```{r}
create_and_plot_boxplots(P_long, "_P", 4, "Health_state", "Боксплоты для таксонов по статусу: Здоров/СРК")
```

### Боксплот по возросту и полу

```{r}
create_and_plot_boxplots(P_long, "_P", 3, "interaction(Health_state, Sex)", "Боксплоты для таксона (Пол + статус заболевания)")
```

### Боксплот по возросту и статусу курения

```{r}
create_and_plot_boxplots(P_long, "_P", 3, "interaction(Health_state, Smoking)", "Боксплоты для таксона (Статус курения + статус заболевания)")
```

### Боксплот по возросту и статусу употребления алкоголя

```{r}
create_and_plot_boxplots(P_long, "_P", 3, "interaction(Health_state, Alcohol)", "Боксплоты для таксона (Статус употребления алкоголя + статус заболевания)")
```

## Посмотрим на данные здоровых людей и людей с СРК как на многомерный вектор по всем таксонам и группам

## G - Genus

```{r}
perform_permutation_test <- function(data, filter_pattern) {
  
  combined_bacteria_G <- data %>%
    select(Health_state, ends_with(filter_pattern))
  
  d <- dist(combined_bacteria_G) # euclidean distances between the rows
  fit <- cmdscale(d, eig=TRUE, k=2) # k is the number of dim
  
  df_mds <- data.frame(
    x = fit$points[,1],
    y = fit$points[,2]
  )  
  
  df_full <- cbind(df_mds, combined_info) %>% 
    mutate(Health_state_n = case_when(Health_state == "Health"  ~ 0,
                                      Health_state == "Disease" ~ 1))
  
  msd_plot <- ggplot(df_full, aes(x = x, y = y, color = Health_state)) +
    geom_point() +
    theme_bw() +
    ggtitle("Распределение вектора таксонов в зависимости от группы пациентов")
  
  print(msd_plot)
  
  print("Используя метод пермутаций проверим отличаются ли группы в зависимости от Health_state")
  
  adonis2(d ~ Health_state_n, data = df_full)
}

# Пример вызова функции с использованием другого фильтра
perform_permutation_test(combined_bacteria_clean, "_G")
```

## F - Family (семейство)

```{r}
perform_permutation_test(combined_bacteria_clean, "_F")
```

## C - Class (класс)

```{r}
perform_permutation_test(combined_bacteria_clean, "_C")
```

## O - Order (порядок)

```{r}
perform_permutation_test(combined_bacteria_clean, "_O")
```

## P - Phylum (тип)

```{r}
perform_permutation_test(combined_bacteria_clean, "_P")
```

### Влияние серотонинпродуцирующих бактерий

```{r}
library("lme4")
library("stringr")


#Переменная имеет биномиальное распределение
plot(data_long$Серотонин)

#Процент пропущенных значений в переменной Серотонин 96,67%
na_serotonin <- sum(is.na(data_long$Серотонин)) / nrow(data_long) * 100


#Данные о серотонине есть только в F и G taxons
serotonin_taxons <- data_long %>%
  filter(!is.na(`Серотонин`)) %>%
  mutate(Serotonin_taxons = str_sub(Taxon, -2)) %>%
  distinct(Serotonin_taxons) %>%
  pull(Serotonin_taxons)

#При этом только 2 F таксона и 42 G таксона
serotonin_taxons_count_unique <- bac_functions %>%
  filter(!is.na(Серотонин)) %>%
  mutate(Serotonin_taxons = str_sub(Taxon, -2)) %>%
  count(Serotonin_taxons)

#А всего 219 F в датасете
num_unique_F <- data_long %>%
  filter(str_detect(Taxon, "_F$")) %>%
  summarise(Num_Unique = n_distinct(Taxon)) %>%
  pull(Num_Unique)

```

###Добавляем данные по родам из двух семейств в bac_functions (данные добавлены в 8-й лист Bacterial group functions.xlsx)

```{r}

# Чтение листов Excel-файла с функциями бактерий и их объединение
path <- "data/raw/Bacterial group functions.xlsx"
taxon <- c ("TaxonName", "Rank")

neuromediators_1 <- read_xlsx (path, 8) %>% 
  mutate(Destroy = ifelse(is.na (Destroy), "produce", "destroy")) %>% 
  unique() %>%
  pivot_wider(names_from = Neuromediator, values_from = Destroy)

probiotics <- read_xlsx (path, 3) %>% 
  add_column(probiotics = 1)

special_properties <- read_xlsx (path, 4) %>% 
  add_column(special_properties = 1)

vitamins <- read_xlsx (path, 5) %>% 
  pivot_wider (names_from = Vitamin, values_from = Vitamin,
               values_fn = function(x) ifelse(is.na (x), NA, 1))

habbits <- read_xlsx (path, 7) %>%
  unique() %>% #удаление повторяющихся строк 
  pivot_wider(names_from = Habbit, values_from = Habit_state)

bac_functions_1 <- read_xlsx (path, 1) %>% #Патогены и нежелательные
  full_join(neuromediators_1, by = taxon) %>% #Нейромедиаторы
  full_join(probiotics, by = taxon) %>% #Пробиотики
  full_join(special_properties, by = taxon) %>% #С особыми свойствами
  full_join(vitamins, by = taxon) %>%  #Витамины
  full_join(read_xlsx (path, 6), by = taxon) %>% #Продуценты КЦДК
  full_join(habbits, by = taxon) %>% #Вредные привычки
  
  unite("Taxon", TaxonName, Rank, sep = "_") %>% 
  filter (Taxon != "Blautia obeum_S") %>% #для данного таксона противоречивая информация в Продуценты КЦЖК
  mutate_all(as.factor)

rm (path, taxon, neuromediators_1, probiotics, special_properties, vitamins, habbits)


data_long_1 <- data_wide %>% 
  pivot_longer(ends_with(c("_D", "_P", "_O", "_C", "_F", "_G")),
               names_to = "Taxon", values_to = "Percentage")

#Перезапись data_long с добавлением функций бактерий
data_long_1 <- data_long_1 %>% 
  left_join (bac_functions_1, by = "Taxon")


G_long_1 <- data_long_1 %>% subset(grepl("_G", Taxon)) 

```

#Модель отдельно для таксонов G уровня

```{r}

G_long_serotonin <- G_long_1 %>%
  filter( ! is.na(`Серотонин`)) %>%
  filter(Percentage > 0.0000)

G_long_serotonin$`Серотонин` <- relevel(G_long_serotonin$`Серотонин`, ref = "destroy")

G_long_serotonin$research_ID <- as.factor(G_long_serotonin$research_ID)
G_long_serotonin$Seq_date <- as.factor(G_long_serotonin$Seq_date)
G_long_serotonin$Seq_date <- as.factor(G_long_serotonin$Seq_date)
G_long_serotonin$patient_ID <- as.factor(G_long_serotonin$patient_ID)



model_ser_G_1 <- glmer(Health_state ~ Серотонин +  (1 | research_ID), data = G_long_serotonin, family = binomial)
summary(model_ser_G_1)

```

Модель не показывает значимой ассоциации наличия серотонинпродуцирующих бактерий и состоянием здоровья человека (СРК/здоровый).

#Boruta for Random Forest, only G-level taxa
```{r}
data_boruta <- data_wide_batched %>%
  select(ends_with("_G") | "Health_state") # selection of taxa _G in dataset corrected for batch-effect (id reasearch)

```


```{r}
library(Boruta)
Boruta(Health_state ~ ., data_boruta, ntree = 1000, maxRuns = 1000) %>% #Boruta 
  TentativeRoughFix() -> boruta_trained

boruta_trained %>%
  attStats() %>%
  rownames_to_column("Переменная") %>%
  mutate(`Переменная` = `Переменная` %>% fct_reorder(`meanImp`)) %>% 
  filter(decision == "Confirmed") %>% 
  select("Переменная") -> boruta_trained_confirmed #dataset with significant variables
```


## Boruta Visualization 
```{r, fig.height=120, fig.width=90,}
boruta_trained %>%
  attStats() %>%
  rownames_to_column("Переменная") %>%
  mutate(`Переменная` = `Переменная` %>% fct_reorder(`meanImp`)) %>% filter(decision == "Confirmed") %>%
  
  ggplot(aes(y = `Переменная`, x = meanImp, colour = decision, size = 4)) +
  geom_point(aes(size = 8)) +
  geom_errorbar(aes(xmin = minImp, xmax = maxImp, width = 3)) +
  xlab("Среднее снижение энтропии") +
  labs(color = "Значимость переменной") +
  theme(legend.position = "bottom", axis.text = element_text(size =70)) 
```


# Random Forest
## RF Dataset

```{r}

data_wide_batched %>%
  select(c(boruta_trained_batched_confirmed$Переменная, Health_state)) -> data_RF

data_RF %>%
  map(function(x) sum(is.na(x)) / length(x)) %>%
  enframe() %>%
  unnest(cols = value) %>%
  arrange(desc(value))

data_RF%>%
  select(where(is.factor)) %>%
  map(table)

```

## RF Test/train data
```{r}
library(rsample)
data_RF <- data_RF[sample(nrow(data_RF)), ]

split_train_RandFor <- initial_split(data_RF, strata = Health_state, prop = 0.9)

data_RandFor_train <- split_train_RandFor %>% training()
data_RandFor_test <- split_train_RandFor %>% testing() 

```

## RF Test data (only research ID = 4)
```{r}
data_RandFor_test_alternative <- data_wide %>% #data for test of model, only research 4, becase both value of variable Health_state
  filter(research_ID == 4)
```

```{r}

cat_metric <- yardstick::metric_set(
  
    yardstick::bal_accuracy,
    yardstick::precision,
    yardstick::recall,
    yardstick::f_meas,
    yardstick::sensitivity,
    yardstick::specificity,
    yardstick::j_index
  
  )

```

## RF Preparing recipe

```{r}
library(themis)
library(embed)

data_recipe_RandFor <- recipe(Health_state ~ ., data_RandFor_train) %>%
  
  step_impute_bag(all_numeric_predictors()) %>%
  step_zv(all_predictors()) %>%
  step_nzv(all_predictors()) %>%
  step_lincomb(all_numeric_predictors()) %>%
  step_normalize(all_numeric_predictors()) 

```

## RF Model

```{r}
library(parsnip)
rf_model <- rand_forest(mode = "classification", mtry = tune(), trees = tune(), min_n = tune()) %>%
  set_engine("ranger")

```

## RF Samples  

```{r}
cv_samples <- vfold_cv(data_RandFor_train, strata = Health_state, v = 10)
```

## RF Parameters grid 

```{r}
library(dials)

parameters_grid <- grid_max_entropy(mtry(range = c(3, 10)), trees(), min_n(), size = 20)
```

## RF Pipeline

```{r}
library(workflows)
reg_workflow <- workflow() %>%
  add_recipe(data_recipe_RandFor) %>%
  add_model(rf_model)
```

## RF Education of model 

```{r}
library(tidymodels)
grid_search <- reg_workflow %>%
  
 tune_grid(
    
    object = reg_workflow,
    resamples = cv_samples,
    grid = parameters_grid,
    control = control_grid(save_pred = TRUE),

    metrics = metric_set(sensitivity, specificity, j_index)

  )

```

## RF Visualization

```{r}
grid_search %>%
  collect_metrics() %>%
  ggplot(aes(trees, mean, color = .metric)) + 
  geom_errorbar(aes(ymin = mean - std_err, ymax = mean + std_err), alpha = 0.8) +
  geom_line(size = 1)

```

## RF Best model selection

```{r}
best_by_j_index <- grid_search %>% select_best("j_index")

final_reg_model <- finalize_workflow(
  
  reg_workflow,
  best_by_j_index
  
)

```

## RF Metrics comparison on train/test data
```{r}

# test data

final_reg_model %>%
  fit(data_RandFor_train) %>%
  predict(data_RandFor_test_alternative) %>%
  pull() -> final_RandFor_test_prediction

metrics_on_test <- cat_metric(truth = truth_values, estimate = estimate_values, tibble(truth_values = data_RandFor_test_alternative$Health_state, estimate_values = final_RandFor_test_prediction)) %>% rename(test_estimate = `.estimate`) %>% select(!`.estimator`)

# train data

final_reg_model %>%
  fit(data_RandFor_train) %>%
  predict(data_RandFor_train) %>%
  pull() -> final_RandFor_train_prediction

metrics_on_train <- cat_metric(truth = truth_values, estimate = estimate_values, tibble(truth_values = data_RandFor_train$Health_state, estimate_values = final_RandFor_train_prediction)) %>% rename(train_estimate = `.estimate`) %>% select(!`.estimator`)

# binding

metrics_on_test %>%
  left_join(metrics_on_train, by = ".metric") %>%
  mutate(differencies = train_estimate - test_estimate)

```

## RF Model results

```{r}

last_fit(
  
  final_reg_model,
  split_train_RandFor
  
) -> final_RF_model

final_RF_model %>% write_rds("RandomForest.rds") #saving model

final_RF_model %>%
  extract_workflow() %>%
  predict(data_RandFor_test_alternative, type = "class") %>%
  pull() -> class_prediction

final_RF_model %>%
  extract_workflow() %>%
  predict(data_RandFor_test_alternative, type = "prob") %>%
  pull() -> prob_prediction

RF_model_results <- tibble(truth = data_RandFor_test_alternative$Health_state,
                            estimate = class_prediction,
                            prob_yes = 1 - prob_prediction)

cat_metric(truth = truth, estimate = estimate, RF_model_results) 

RF_model_results %>%
  roc_curve(truth = truth, prob_yes) %>%
  autoplot()

```


